// Function to rotate a vector `v` around an arbitrary axis `axis` by angle `theta`.

Vector rotate_vector (const Vector v, const Vector axis, double theta)

// Apply the rotation operator to rotate `myRay.v` around `cross(Normal, z)` by `dot(Normal, z)`.

Vector z_axis = make_vector(0.0, 0.0, 1.0);
double rotation_angle = dot(Normal, z_axis);
myRay.v = rotate_vector(myRay.v, cross(Normal, z_axis), rotation_angle);

// Rotate `myRay.v` around `x = (1, 0, 0)` by `2 * dot(myRay.v, z)`.
double x_rotation_angle = 2 * dot(myRay.v, z_axis);
myRay.v = rotate_vector(myRay.v, make_vector(1.0, 0.0, 0.0), x_rotation_angle);

// Apply the complex conjugate of the rotation operator.
myRay.v = conj(rotate_vector(myRay.v, cross(Normal, z_axis), -rotation_angle));

>>>>>>>


double k, j, theta, VdotN;
			Vector Out;
			myRay.v = mult(myRay.v, -1.0);  //Note math easier if I flip my incident ray
			if(acos(dot(Normal,myRay.v)) > PI/2.0) 
				Normal = mult(Normal, -1.0); //Normal facing wrong way

			theta = acos(dot(Normal, myRay.v));

			VdotN = dot(myRay.v, Normal); //note both unit vectors
			if (VdotN == 1.0) {
				//vectors are colinear! Normal reflection!
				k = 1;
				j = 0;
			} else {
				k = ((cos(2.0*theta)*VdotN)-cos(theta))/(pow(VdotN,2.0) - 1.0);
				j = cos(2.0*theta) - (k*VdotN);

			} 
			Out = add(mult(myRay.v,j),mult(Normal,k));
			Out = unit(Out); // just checking, but needless otherwise math is wrong
			myRay.v = Out;


